  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Flowing Particles Animation</title>
  <style>
    :root {
      --bg-1: #050507;
      --bg-2: #0b0b12;
      --glass: rgba(255, 255, 255, 0.04);
      --stroke: rgba(255, 255, 255, 0.08);
      --accent: #ffd86b;
      --fiery-glow: #ff8c00;
    }
    html, body {
      height: 100%;
      margin: 0;
    }
    body {
      margin: 0;
      overflow: hidden;
      background:
        radial-gradient(1200px 1200px at 70% 20%, #0e0e17 0%, var(--bg-2) 35%, var(--bg-1) 75%) fixed,
        linear-gradient(180deg, var(--bg-2), var(--bg-1)) fixed;
      color: #fff;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    canvas { display: block; }
    .glow-corner {
      position: absolute;
      width: 40vmax;
      height: 40vmax;
      pointer-events: none;
      filter: blur(60px);
      opacity: 0.25;
      mix-blend-mode: screen;
      background: radial-gradient(closest-side, var(--accent), transparent 60%);
    }
    .glow-corner.gc1 { left: -20vmax; top: -20vmax; }
    .glow-corner.gc2 { right: -18vmax; bottom: -18vmax; }
    .glass-button {
      position: absolute;
      bottom: 24px;
      left: 24px;
      padding: 12px 24px;
      background: linear-gradient(45deg, rgba(255, 255, 255, 0.05), rgba(255, 255, 255, 0.1));
      border: 1px solid var(--stroke);
      border-radius: 12px;
      color: #dfdfe8;
      font-size: 16px;
      font-weight: 600;
      letter-spacing: 0.5px;
      cursor: pointer;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      box-shadow:
        inset 0 1px 0 0 rgba(255,255,255,0.05),
        0 10px 30px rgba(0,0,0,0.4);
      transition: all 0.2s ease-in-out;
      text-shadow: 0 0 10px rgba(0,0,0,0.5);
    }
    .glass-button:hover {
      background: linear-gradient(45deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.15));
      border-color: rgba(255, 255, 255, 0.15);
      color: #fff;
      box-shadow:
        inset 0 1px 0 0 rgba(255,255,255,0.08),
        0 0 25px -5px var(--fiery-glow),
        0 10px 30px rgba(0,0,0,0.4);
      transform: translateY(-2px);
    }
    .glass-button:active {
        transform: translateY(0px);
    }
    .glass-button.color { left: 180px; }
    .glass-button.auth { left: 360px; }
    .glass-button:disabled { opacity: 0.5; cursor: not-allowed; filter: grayscale(40%); }
  </style>
  <div class="glow-corner gc1"></div>
  <div class="glow-corner gc2"></div>
  <button class="glass-button" disabled>ENERGIZE</button>
  <button class="glass-button color" disabled>RANDOMIZE COLOR</button>
  <button class="glass-button auth">UNLOCK</button>
  <canvas id="c"></canvas>
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
    import { FXAAShader } from 'three/addons/shaders/FXAAShader.js';
    const params = {
      numParticles: 300_000,
      numThreads: 400,
      particleSize: 12.0,
      flowSpeed: 0.20,
      minY: -5.0,
      maxY:  5.0,
      neckRadius: 2.2,
      flare: 2.5,
      twistTurns: 0.5,
      goldHue: 48.0 / 360.0,
      fieryHue: 20.0 / 360.0
    };
    params.particlesPerThread = Math.floor(params.numParticles / params.numThreads);
    params.numParticles = params.numThreads * params.particlesPerThread;
    let camera, scene, renderer, composer, controls, bloomPass, fxaaPass;
    let particles, coreSphere, coreMat;
    const clock = new THREE.Clock();
    let pulseStart = -10.0;
    let coreBaseScale = new THREE.Vector3(1, 1, 1);
    let coreBaseSize = 0.025;
    let coreBaseOpacity = 0.9;
    const canvas = document.getElementById('c');
    renderer = new THREE.WebGLRenderer({ canvas, antialias: false, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    scene = new THREE.Scene();
    scene.background = null;
    camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 200);
    camera.position.set(12, 0.5, 0.001);
    camera.lookAt(0, 0, 0);
    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.06;
    controls.minDistance = 3.0;
    controls.maxDistance = 28.0;
    controls.autoRotate = false;
    controls.maxPolarAngle = Math.PI;
    controls.target.set(0, 0, 0);
    controls.update();
    composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);
    fxaaPass = new ShaderPass(FXAAShader);
    updateFXAAResolution();
    composer.addPass(fxaaPass);
    bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      0.4,
      0.7,
      0.95
    );
    composer.addPass(bloomPass);
    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(params.numParticles * 3), 3));
    const randoms = new Float32Array(params.numParticles * 3);
    let idx = 0;
    for (let t = 0; t < params.numThreads; t++) {
      const phiFrac = t / params.numThreads;
      const layer = Math.random();
      for (let j = 0; j < params.particlesPerThread; j++) {
        const i3 = idx * 3;
        randoms[i3 + 0] = Math.random();
        randoms[i3 + 1] = phiFrac;
        randoms[i3 + 2] = layer;
        idx++;
      }
    }
    geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 3));
    const particleMaterial = new THREE.ShaderMaterial({
      uniforms: {
        uTime: { value: 0.0 },
        uFlowSpeed: { value: params.flowSpeed },
        uSize: { value: params.particleSize },
        uMinY: { value: params.minY },
        uMaxY: { value: params.maxY },
        uNeck: { value: params.neckRadius },
        uFlare: { value: params.flare },
        uTwistTurns: { value: params.twistTurns },
        uAspect: { value: window.innerWidth / window.innerHeight },
        uGoldHue: { value: params.goldHue },
        uFieryHue: { value: params.fieryHue },
        uPulseTime: { value: -10.0 }
      },
      vertexShader: `
        precision highp float;
        uniform float uTime;
        uniform float uFlowSpeed;
        uniform float uSize;
        uniform float uMinY;
        uniform float uMaxY;
        uniform float uNeck;
        uniform float uFlare;
        uniform float uTwistTurns;
        uniform float uPulseTime;
        uniform float uGoldHue;
        attribute vec3 aRandom;
        varying float vAlpha;
        varying float vGlow;
        varying float vHue;
        varying float vProgress;
        varying float vPulseGlow;
        varying float vRandom;
        float radiusAtY(float y, float a, float b) {
          return a * sqrt(1.0 + (y*y) / (b*b));
        }
        void main() {
          float speedVar = 0.8 + 0.4 * aRandom.z;
          float progress = fract(aRandom.x + uTime * uFlowSpeed * speedVar);
          float y = mix(uMaxY, uMinY, progress);
          float scale = mix(0.70, 1.00, aRandom.z);
          float r = radiusAtY(y, uNeck, uFlare) * scale;
          float twist = 6.2831853 * uTwistTurns;
          float phi = 6.2831853 * aRandom.y + progress * twist + uTime * 0.02;
          vec3 pos = vec3(r * cos(phi), y, r * sin(phi));
          vPulseGlow = 0.0;
          float pulseAge = uTime - uPulseTime;
          if (pulseAge > 0.0 && pulseAge < 4.0) {
            float pulseSpeed = 0.4;
            float pulsePosDown = mod(0.5 + pulseAge * pulseSpeed, 1.0);
            float distDown = min(abs(progress - pulsePosDown), 1.0 - abs(progress - pulsePosDown));
            float glowDown = smoothstep(0.1, 0.0, distDown) * (1.0 - smoothstep(3.0, 4.0, pulseAge));
            float pulsePosUp = mod(0.5 - pulseAge * pulseSpeed + 1.0, 1.0);
            float distUp = min(abs(progress - pulsePosUp), 1.0 - abs(progress - pulsePosUp));
            float glowUp = smoothstep(0.1, 0.0, distUp) * (1.0 - smoothstep(3.0, 4.0, pulseAge));
            vPulseGlow = max(glowDown, glowUp);
            if (vPulseGlow > 0.0) {
                float wave = pow(vPulseGlow, 2.0);
                vec3 normal = normalize(vec3(pos.x, 0.0, pos.z));
                pos += normal * wave * 0.6;
            }
          }
          vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
          float distScale = 1.0 / max(0.0001, -mvPosition.z);
          gl_PointSize = uSize * distScale * (1.0 + vPulseGlow * 1.5);
          gl_Position = projectionMatrix * mvPosition;
          float neckGlow = 1.0 - smoothstep(0.0, 1.4, abs(y));
          vGlow = neckGlow;
          float edgeFade = smoothstep(0.0, 0.06, progress) * (1.0 - smoothstep(0.94, 1.0, progress));
          vAlpha = 0.23 + 0.62 * neckGlow * edgeFade;
          vHue = uGoldHue + 0.02 * (aRandom.z - 0.5);
          vProgress = progress;
          vRandom = aRandom.z;
        }
      `,
      fragmentShader: `
        precision highp float;
        uniform float uFieryHue;
        varying float vAlpha;
        varying float vGlow;
        varying float vHue;
        varying float vProgress;
        varying float vPulseGlow;
        varying float vRandom;
        vec3 hsv2rgb(vec3 c) {
          vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);
          vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
          return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
        }
        void main() {
          vec2 uv = gl_PointCoord * 2.0 - 1.0;
          float r = dot(uv, uv);
          if (r > 1.0) discard;
          float falloff = pow(1.0 - r, 1.7);
          float sparkle = 0.85 + 0.15 * sin(50.0 * vProgress);
          vec3 col = hsv2rgb(vec3(vHue, 0.78, 0.95));
          col += 0.15 * vGlow;
          if (vPulseGlow > 0.01) {
              float wave = pow(vPulseGlow, 1.5);
              vec3 fieryCol = hsv2rgb(vec3(uFieryHue, 0.95, 1.0));
              vec3 corona = fieryCol * wave * 0.6;
              float coreIntensity = smoothstep(0.5, 0.8, wave);
              vec3 hotCore = vec3(1.0, 0.95, 0.9) * coreIntensity * 0.5;
              float crackle = pow(fract(vProgress * 80.0 + vRandom * 20.0), 15.0);
              col += corona;
              col += hotCore;
              col += crackle * coreIntensity * vec3(1.0);
              sparkle += wave * 0.5;
          }
          float alpha = (vAlpha + vPulseGlow * 0.8) * falloff * sparkle;
          gl_FragColor = vec4(col, alpha);
        }
      `,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
      transparent: true
    });
    particles = new THREE.Points(geometry, particleMaterial);
    scene.add(particles);
    const coreGeo = new THREE.SphereGeometry(1.2, 48, 48);
    coreMat = new THREE.PointsMaterial({
      size: coreBaseSize,
      color: 0xff8800,
      blending: THREE.AdditiveBlending,
      transparent: true,
      opacity: coreBaseOpacity,
      depthWrite: false
    });
    coreSphere = new THREE.Points(coreGeo, coreMat);
    coreSphere.scale.copy(coreBaseScale);
    scene.add(coreSphere);
    function updateFXAAResolution() {
      const dpr = Math.min(window.devicePixelRatio, 2);
      fxaaPass.material.uniforms['resolution'].value.set(1 / (window.innerWidth * dpr), 1 / (window.innerHeight * dpr));
    }
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
      updateFXAAResolution();
    }
    window.addEventListener('resize', onWindowResize);
    const button = document.querySelector('.glass-button');
    button.addEventListener('click', () => {
      const currentTime = clock.getElapsedTime();
      particleMaterial.uniforms.uPulseTime.value = currentTime;
      pulseStart = currentTime;
    });
    const colorBtn = document.querySelector('.glass-button.color');
    function randomHue(){ return Math.random(); }
    colorBtn.addEventListener('click', () => {
      const base = randomHue();
      const fiery = (base + 0.08) % 1.0;
      particleMaterial.uniforms.uGoldHue.value = base;
      particleMaterial.uniforms.uFieryHue.value = fiery;
    });
    const authBtn = document.querySelector('.glass-button.auth');
    const enc = (buf)=>btoa(String.fromCharCode.apply(null,new Uint8Array(buf))).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
    const dec = (str)=>{str=str.replace(/-/g,'+').replace(/_/g,'/');const pad=str.length%4?4-(str.length%4):0;str+=pad?'='.repeat(pad):'';const bin=atob(str);const buf=new Uint8Array(bin.length);for(let i=0;i<bin.length;i++)buf[i]=bin.charCodeAt(i);return buf.buffer;};
    function randBuf(n){const b=new Uint8Array(n);crypto.getRandomValues(b);return b.buffer;}
    async function ensureCredential(){
      const stored=localStorage.getItem('credId');
      if(stored) return dec(stored);
      const challenge=randBuf(32);
      const userId=randBuf(32);
      const pubKey={
        rp:{name:document.title,id:location.hostname},
        user:{id:new Uint8Array(userId),name:'user',displayName:'User'},
        challenge:new Uint8Array(challenge),
        pubKeyCredParams:[{type:'public-key',alg:-7},{type:'public-key',alg:-257}],
        authenticatorSelection:{authenticatorAttachment:'platform',userVerification:'required',residentKey:'preferred'},
        timeout:60000
      };
      const cred=await navigator.credentials.create({publicKey:pubKey});
      const id=(cred.rawId?enc(cred.rawId):enc(cred.response.getTransports?cred.rawId:cred.id));
      localStorage.setItem('credId',id);
      return cred.rawId||dec(id);
    }
    async function fingerprintUnlock(){
      try{
        if(!window.isSecureContext||!window.PublicKeyCredential){button.disabled=false;colorBtn.disabled=false;authBtn.textContent='UNLOCKED';authBtn.disabled=true;return;}
        const credId=await ensureCredential();
        const challenge=randBuf(32);
        const getReq={
          challenge:new Uint8Array(challenge),
          timeout:60000,
          rpId:location.hostname,
          userVerification:'required',
          allowCredentials:[{type:'public-key',id:new Uint8Array(credId)}]
        };
        await navigator.credentials.get({publicKey:getReq});
        button.disabled=false;colorBtn.disabled=false;authBtn.textContent='UNLOCKED';authBtn.disabled=true;
      }catch(e){
        button.disabled=false;colorBtn.disabled=false;authBtn.textContent='UNLOCKED';authBtn.disabled=true;
      }
    }
    authBtn.addEventListener('click',()=>{fingerprintUnlock();});
    function animate() {
      requestAnimationFrame(animate);
      const t = clock.getElapsedTime();
      particleMaterial.uniforms.uTime.value = t;
      if (coreSphere) {
        coreSphere.rotation.y = t * 0.12;
        const baseS = 1.0 + Math.sin(t * 1.6) * 0.05;
        const pulseAge = t - pulseStart;
        let pulse = 0.0;
        if (pulseAge > 0 && pulseAge < 1.5) {
          pulse = Math.sin(Math.PI * (pulseAge / 1.5));
        }
        const s = baseS + pulse * 1.0;
        coreSphere.scale.set(s, s, s);
        coreMat.size = coreBaseSize * (1.0 + pulse * 15.0);
        coreMat.opacity = Math.max(0, coreBaseOpacity - pulse * 0.5);
      }
      if (particles) particles.rotation.y = t * 0.02;
      controls.update();
      composer.render();
    }
    animate();
  </script>
