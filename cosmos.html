  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Flowing Particles Animation</title>
  <style>
    :root {
      --bg-1: #050507;
      --bg-2: #0b0b12;
      --glass: rgba(255, 255, 255, 0.04);
      --stroke: rgba(255, 255, 255, 0.08);
      --accent: #ffd86b;
      --fiery-glow: #ff8c00;
    }
    html, body {
      height: 100%;
      margin: 0;
    }
    body {
      margin: 0;
      overflow: hidden;
      background:
        radial-gradient(1200px 1200px at 70% 20%, #0e0e17 0%, var(--bg-2) 35%, var(--bg-1) 75%) fixed,
        linear-gradient(180deg, var(--bg-2), var(--bg-1)) fixed;
      color: #fff;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    canvas { display: block; }
    .glow-corner {
      position: absolute;
      width: 40vmax;
      height: 40vmax;
      pointer-events: none;
      filter: blur(60px);
      opacity: 0.25;
      mix-blend-mode: screen;
      background: radial-gradient(closest-side, var(--accent), transparent 60%);
    }
    .glow-corner.gc1 { left: -20vmax; top: -20vmax; }
    .glow-corner.gc2 { right: -18vmax; bottom: -18vmax; }
    .glass-button {
      position: absolute;
      bottom: 24px;
      left: 24px;
      padding: 12px 24px;
      background: linear-gradient(45deg, rgba(255, 255, 255, 0.05), rgba(255, 255, 255, 0.1));
      border: 1px solid var(--stroke);
      border-radius: 12px;
      color: #dfdfe8;
      font-size: 16px;
      font-weight: 600;
      letter-spacing: 0.5px;
      cursor: pointer;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      box-shadow:
        inset 0 1px 0 0 rgba(255,255,255,0.05),
        0 10px 30px rgba(0,0,0,0.4);
      transition: all 0.2s ease-in-out;
      text-shadow: 0 0 10px rgba(0,0,0,0.5);
    }
    .glass-button:hover {
      background: linear-gradient(45deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.15));
      border-color: rgba(255, 255, 255, 0.15);
      color: #fff;
      box-shadow:
        inset 0 1px 0 0 rgba(255,255,255,0.08),
        0 0 25px -5px var(--fiery-glow),
        0 10px 30px rgba(0,0,0,0.4);
      transform: translateY(-2px);
    }
    .glass-button:active {
        transform: translateY(0px);
    }
  </style>
  <div class="glow-corner gc1"></div>
  <div class="glow-corner gc2"></div>
  <button class="glass-button">ENERGIZE</button>
  <canvas id="c"></canvas>
  <script type="x-disabled">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/"
      }
    }
  </script>
  <script type="x-disabled">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
    import { FXAAShader } from 'three/addons/shaders/FXAAShader.js';
    const params = {
      numParticles: 300_000,
      numThreads: 400,
      particleSize: 12.0,
      flowSpeed: 0.20,
      minY: -5.0,
      maxY:  5.0,
      neckRadius: 2.2,
      flare: 2.5,
      twistTurns: 0.5,
      goldHue: 48.0 / 360.0,
      fieryHue: 20.0 / 360.0
    };
    params.particlesPerThread = Math.floor(params.numParticles / params.numThreads);
    params.numParticles = params.numThreads * params.particlesPerThread;
    let camera, scene, renderer, composer, controls, bloomPass, fxaaPass;
    let particles, coreSphere, coreMat;
    const clock = new THREE.Clock();
    let pulseStart = -10.0;
    let coreBaseScale = new THREE.Vector3(1, 1, 1);
    let coreBaseSize = 0.025;
    let coreBaseOpacity = 0.9;
    const canvas = document.getElementById('c');
    renderer = new THREE.WebGLRenderer({ canvas, antialias: false, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    scene = new THREE.Scene();
    scene.background = null;
    camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 200);
    camera.position.set(12, 0.5, 0.001);
    camera.lookAt(0, 0, 0);
    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.06;
    controls.minDistance = 3.0;
    controls.maxDistance = 28.0;
    controls.autoRotate = false;
    controls.maxPolarAngle = Math.PI;
    controls.target.set(0, 0, 0);
    controls.update();
    composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);
    fxaaPass = new ShaderPass(FXAAShader);
    updateFXAAResolution();
    composer.addPass(fxaaPass);
    bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      0.4,
      0.7,
      0.95
    );
    composer.addPass(bloomPass);
    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(params.numParticles * 3), 3));
    const randoms = new Float32Array(params.numParticles * 3);
    let idx = 0;
    for (let t = 0; t < params.numThreads; t++) {
      const phiFrac = t / params.numThreads;
      const layer = Math.random();
      for (let j = 0; j < params.particlesPerThread; j++) {
        const i3 = idx * 3;
        randoms[i3 + 0] = Math.random();
        randoms[i3 + 1] = phiFrac;
        randoms[i3 + 2] = layer;
        idx++;
      }
    }
    geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 3));
    const particleMaterial = new THREE.ShaderMaterial({
      uniforms: {
        uTime: { value: 0.0 },
        uFlowSpeed: { value: params.flowSpeed },
        uSize: { value: params.particleSize },
        uMinY: { value: params.minY },
        uMaxY: { value: params.maxY },
        uNeck: { value: params.neckRadius },
        uFlare: { value: params.flare },
        uTwistTurns: { value: params.twistTurns },
        uAspect: { value: window.innerWidth / window.innerHeight },
        uGoldHue: { value: params.goldHue },
        uFieryHue: { value: params.fieryHue },
        uPulseTime: { value: -10.0 }
      },
      vertexShader: `
        precision highp float;
        uniform float uTime;
        uniform float uFlowSpeed;
        uniform float uSize;
        uniform float uMinY;
        uniform float uMaxY;
        uniform float uNeck;
        uniform float uFlare;
        uniform float uTwistTurns;
        uniform float uPulseTime;
        attribute vec3 aRandom;
        varying float vAlpha;
        varying float vGlow;
        varying float vHue;
        varying float vProgress;
        varying float vPulseGlow;
        varying float vRandom;
        float radiusAtY(float y, float a, float b) {
          return a * sqrt(1.0 + (y*y) / (b*b));
        }
        void main() {
          float speedVar = 0.8 + 0.4 * aRandom.z;
          float progress = fract(aRandom.x + uTime * uFlowSpeed * speedVar);
          float y = mix(uMaxY, uMinY, progress);
          float scale = mix(0.70, 1.00, aRandom.z);
          float r = radiusAtY(y, uNeck, uFlare) * scale;
          float twist = 6.2831853 * uTwistTurns;
          float phi = 6.2831853 * aRandom.y + progress * twist + uTime * 0.02;
          vec3 pos = vec3(r * cos(phi), y, r * sin(phi));
          vPulseGlow = 0.0;
          float pulseAge = uTime - uPulseTime;
          if (pulseAge > 0.0 && pulseAge < 4.0) {
            float pulseSpeed = 0.4;
            float pulsePosDown = mod(0.5 + pulseAge * pulseSpeed, 1.0);
            float distDown = min(abs(progress - pulsePosDown), 1.0 - abs(progress - pulsePosDown));
            float glowDown = smoothstep(0.1, 0.0, distDown) * (1.0 - smoothstep(3.0, 4.0, pulseAge));
            float pulsePosUp = mod(0.5 - pulseAge * pulseSpeed + 1.0, 1.0);
            float distUp = min(abs(progress - pulsePosUp), 1.0 - abs(progress - pulsePosUp));
            float glowUp = smoothstep(0.1, 0.0, distUp) * (1.0 - smoothstep(3.0, 4.0, pulseAge));
            vPulseGlow = max(glowDown, glowUp);
            if (vPulseGlow > 0.0) {
                float wave = pow(vPulseGlow, 2.0);
                vec3 normal = normalize(vec3(pos.x, 0.0, pos.z));
                pos += normal * wave * 0.6;
            }
          }
          vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
          float distScale = 1.0 / max(0.0001, -mvPosition.z);
          gl_PointSize = uSize * distScale * (1.0 + vPulseGlow * 1.5);
          gl_Position = projectionMatrix * mvPosition;
          float neckGlow = 1.0 - smoothstep(0.0, 1.4, abs(y));
          vGlow = neckGlow;
          float edgeFade = smoothstep(0.0, 0.06, progress) * (1.0 - smoothstep(0.94, 1.0, progress));
          vAlpha = 0.23 + 0.62 * neckGlow * edgeFade;
          vHue = ${params.goldHue.toFixed(6)} + 0.02 * (aRandom.z - 0.5);
          vProgress = progress;
          vRandom = aRandom.z;
        }
      `,
      fragmentShader: `
        precision highp float;
        uniform float uFieryHue;
        varying float vAlpha;
        varying float vGlow;
        varying float vHue;
        varying float vProgress;
        varying float vPulseGlow;
        varying float vRandom;
        vec3 hsv2rgb(vec3 c) {
          vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);
          vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
          return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
        }
        void main() {
          vec2 uv = gl_PointCoord * 2.0 - 1.0;
          float r = dot(uv, uv);
          if (r > 1.0) discard;
          float falloff = pow(1.0 - r, 1.7);
          float sparkle = 0.85 + 0.15 * sin(50.0 * vProgress);
          vec3 col = hsv2rgb(vec3(vHue, 0.78, 0.95));
          col += 0.15 * vGlow;
          if (vPulseGlow > 0.01) {
              float wave = pow(vPulseGlow, 1.5);
              vec3 fieryCol = hsv2rgb(vec3(uFieryHue, 0.95, 1.0));
              vec3 corona = fieryCol * wave * 0.6;
              float coreIntensity = smoothstep(0.5, 0.8, wave);
              vec3 hotCore = vec3(1.0, 0.95, 0.9) * coreIntensity * 0.5;
              float crackle = pow(fract(vProgress * 80.0 + vRandom * 20.0), 15.0);
              col += corona;
              col += hotCore;
              col += crackle * coreIntensity * vec3(1.0);
              sparkle += wave * 0.5;
          }
          float alpha = (vAlpha + vPulseGlow * 0.8) * falloff * sparkle;
          gl_FragColor = vec4(col, alpha);
        }
      `,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
      transparent: true
    });
    particles = new THREE.Points(geometry, particleMaterial);
    scene.add(particles);
    const coreGeo = new THREE.SphereGeometry(1.2, 48, 48);
    coreMat = new THREE.PointsMaterial({
      size: coreBaseSize,
      color: 0xff8800,
      blending: THREE.AdditiveBlending,
      transparent: true,
      opacity: coreBaseOpacity,
      depthWrite: false
    });
    coreSphere = new THREE.Points(coreGeo, coreMat);
    coreSphere.scale.copy(coreBaseScale);
    scene.add(coreSphere);
    function updateFXAAResolution() {
      const dpr = Math.min(window.devicePixelRatio, 2);
      fxaaPass.material.uniforms['resolution'].value.set(1 / (window.innerWidth * dpr), 1 / (window.innerHeight * dpr));
    }
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
      updateFXAAResolution();
    }
    window.addEventListener('resize', onWindowResize);
    const button = document.querySelector('.glass-button');
    button.addEventListener('click', () => {
      const currentTime = clock.getElapsedTime();
      particleMaterial.uniforms.uPulseTime.value = currentTime;
      pulseStart = currentTime;
    });
    function animate() {
      requestAnimationFrame(animate);
      const t = clock.getElapsedTime();
      particleMaterial.uniforms.uTime.value = t;
      if (coreSphere) {
        coreSphere.rotation.y = t * 0.12;
        const baseS = 1.0 + Math.sin(t * 1.6) * 0.05;
        const pulseAge = t - pulseStart;
        let pulse = 0.0;
        if (pulseAge > 0 && pulseAge < 1.5) {
          pulse = Math.sin(Math.PI * (pulseAge / 1.5));
        }
        const s = baseS + pulse * 1.0;
        coreSphere.scale.set(s, s, s);
        coreMat.size = coreBaseSize * (1.0 + pulse * 15.0);
        coreMat.opacity = Math.max(0, coreBaseOpacity - pulse * 0.5);
      }
      if (particles) particles.rotation.y = t * 0.02;
      controls.update();
      composer.render();
    }
    animate();
  </script>
  <script>
    const params={numParticles:200000,numThreads:400,particleSize:12.0,flowSpeed:0.20,minY:-5.0,maxY:5.0,neckRadius:2.2,flare:2.5,twistTurns:0.5,goldHue:48/360,fieryHue:20/360};
    params.particlesPerThread=Math.floor(params.numParticles/params.numThreads);
    params.numParticles=params.numThreads*params.particlesPerThread;
    const canvas=document.getElementById('c');
    const gl=canvas.getContext('webgl2',{antialias:false,alpha:true,premultipliedAlpha:false});
    function makeProgram(vsSrc,fsSrc){function sh(type,src){const s=gl.createShader(type);gl.shaderSource(s,src);gl.compileShader(s);if(!gl.getShaderParameter(s,gl.COMPILE_STATUS))throw new Error(gl.getShaderInfoLog(s)||'shader');return s}const p=gl.createProgram();gl.attachShader(p,sh(gl.VERTEX_SHADER,vsSrc));gl.attachShader(p,sh(gl.FRAGMENT_SHADER,fsSrc));gl.linkProgram(p);if(!gl.getProgramParameter(p,gl.LINK_STATUS))throw new Error(gl.getProgramInfoLog(p)||'program');return p}
    const vs=`#version 300 es
    precision highp float;
    layout(location=0) in vec3 aRandom;
    uniform float uTime,uFlowSpeed,uSize,uMinY,uMaxY,uNeck,uFlare,uTwistTurns,uPulseTime;
    uniform mat4 uProj,uView;
    out float vAlpha;
    out float vGlow;
    out float vHue;
    out float vProgress;
    out float vPulseGlow;
    out float vRandom;
    float radiusAtY(float y,float a,float b){return a*sqrt(1.0+(y*y)/(b*b));}
    void main(){
      float speedVar=0.8+0.4*aRandom.z;
      float progress=fract(aRandom.x+uTime*uFlowSpeed*speedVar);
      float y=mix(uMaxY,uMinY,progress);
      float scale=mix(0.70,1.00,aRandom.z);
      float r=radiusAtY(y,uNeck,uFlare)*scale;
      float twist=6.2831853*uTwistTurns;
      float phi=6.2831853*aRandom.y+progress*twist+uTime*0.02;
      vec3 pos=vec3(r*cos(phi),y,r*sin(phi));
      vPulseGlow=0.0;
      float pulseAge=uTime-uPulseTime;
      if(pulseAge>0.0&&pulseAge<4.0){
        float pulseSpeed=0.4;
        float pulsePosDown=mod(0.5+pulseAge*pulseSpeed,1.0);
        float distDown=min(abs(progress-pulsePosDown),1.0-abs(progress-pulsePosDown));
        float glowDown=smoothstep(0.1,0.0,distDown)*(1.0-smoothstep(3.0,4.0,pulseAge));
        float pulsePosUp=mod(0.5-pulseAge*pulseSpeed+1.0,1.0);
        float distUp=min(abs(progress-pulsePosUp),1.0-abs(progress-pulsePosUp));
        float glowUp=smoothstep(0.1,0.0,distUp)*(1.0-smoothstep(3.0,4.0,pulseAge));
        vPulseGlow=max(glowDown,glowUp);
        if(vPulseGlow>0.0){
          float wave=pow(vPulseGlow,2.0);
          vec3 normal=normalize(vec3(pos.x,0.0,pos.z));
          pos+=normal*wave*0.6;
        }
      }
      vec4 pv=uView*vec4(pos,1.0);
      float distScale=1.0/max(0.0001,-pv.z);
      gl_PointSize=uSize*distScale*(1.0+vPulseGlow*1.5);
      gl_Position=uProj*pv;
      float neckGlow=1.0-smoothstep(0.0,1.4,abs(y));
      vGlow=neckGlow;
      float edgeFade=smoothstep(0.0,0.06,progress)*(1.0-smoothstep(0.94,1.0,progress));
      vAlpha=0.23+0.62*neckGlow*edgeFade;
      vHue=0.133333+0.02*(aRandom.z-0.5);
      vProgress=progress;
      vRandom=aRandom.z;
    }`;
    const fs=`#version 300 es
    precision highp float;
    uniform float uFieryHue;
    in float vAlpha;
    in float vGlow;
    in float vHue;
    in float vProgress;
    in float vPulseGlow;
    in float vRandom;
    out vec4 outColor;
    vec3 hsv2rgb(vec3 c){vec4 K=vec4(1.0,2.0/3.0,1.0/3.0,3.0);vec3 p=abs(fract(c.xxx+K.xyz)*6.0-K.www);return c.z*mix(K.xxx,clamp(p-K.xxx,0.0,1.0),c.y);}
    void main(){
      vec2 uv=gl_PointCoord*2.0-1.0;
      float r=dot(uv,uv);
      if(r>1.0) discard;
      float falloff=pow(1.0-r,1.7);
      float sparkle=0.85+0.15*sin(50.0*vProgress);
      vec3 col=hsv2rgb(vec3(vHue,0.78,0.95));
      col+=0.15*vGlow;
      if(vPulseGlow>0.01){
        float wave=pow(vPulseGlow,1.5);
        vec3 fieryCol=hsv2rgb(vec3(uFieryHue,0.95,1.0));
        vec3 corona=fieryCol*wave*0.6;
        float coreIntensity=smoothstep(0.5,0.8,wave);
        vec3 hotCore=vec3(1.0,0.95,0.9)*coreIntensity*0.5;
        float crackle=pow(fract(vProgress*80.0+vRandom*20.0),15.0);
        col+=corona;
        col+=hotCore;
        col+=crackle*coreIntensity*vec3(1.0);
        sparkle+=wave*0.5;
      }
      float alpha=(vAlpha+vPulseGlow*0.8)*falloff*sparkle;
      outColor=vec4(col,alpha);
    }`;
    const program=makeProgram(vs,fs);
    gl.useProgram(program);
    const randData=new Float32Array(params.numParticles*3);
    let idx=0;
    for(let t=0;t<params.numThreads;t++){const phiFrac=t/params.numThreads;const layer=Math.random();for(let j=0;j<params.particlesPerThread;j++){const i3=idx*3;randData[i3]=Math.random();randData[i3+1]=phiFrac;randData[i3+2]=layer;idx++;}}
    const vbo=gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER,vbo);
    gl.bufferData(gl.ARRAY_BUFFER,randData,gl.STATIC_DRAW);
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(0,3,gl.FLOAT,false,0,0);
    const loc={uTime:gl.getUniformLocation(program,'uTime'),uFlowSpeed:gl.getUniformLocation(program,'uFlowSpeed'),uSize:gl.getUniformLocation(program,'uSize'),uMinY:gl.getUniformLocation(program,'uMinY'),uMaxY:gl.getUniformLocation(program,'uMaxY'),uNeck:gl.getUniformLocation(program,'uNeck'),uFlare:gl.getUniformLocation(program,'uFlare'),uTwistTurns:gl.getUniformLocation(program,'uTwistTurns'),uPulseTime:gl.getUniformLocation(program,'uPulseTime'),uFieryHue:gl.getUniformLocation(program,'uFieryHue'),uProj:gl.getUniformLocation(program,'uProj'),uView:gl.getUniformLocation(program,'uView')};
    function perspective(fovy,aspect,near,far){const f=1/Math.tan(fovy/2),nf=1/(near-far);return new Float32Array([f/aspect,0,0,0,0,f,0,0,0,0,(far+near)*nf,-1,0,0,(2*far*near)*nf,0])}
    function normalize(v){const n=Math.hypot(v[0],v[1],v[2])||1;return [v[0]/n,v[1]/n,v[2]/n]}
    function cross(a,b){return [a[1]*b[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],a[0]*b[1]-a[1]*b[0]]}
    function sub(a,b){return [a[0]-b[0],a[1]-b[1],a[2]-b[2]]}
    function lookAt(eye,center,up){const z=normalize(sub(eye,center));const x=normalize(cross(up,z));const y=cross(z,x);return new Float32Array([x[0],y[0],z[0],0,x[1],y[1],z[1],0,x[2],y[2],z[2],0,-(x[0]*eye[0]+x[1]*eye[1]+x[2]*eye[2]),-(y[0]*eye[0]+y[1]*eye[1]+y[2]*eye[2]),-(z[0]*eye[0]+z[1]*eye[1]+z[2]*eye[2]),1])}
    let radius=12,theta=0.0,phi=0.04;
    const minRadius=3,maxRadius=28;
    let dragging=false,lastX=0,lastY=0;
    canvas.addEventListener('mousedown',e=>{dragging=true;lastX=e.clientX;lastY=e.clientY});
    window.addEventListener('mouseup',()=>{dragging=false});
    window.addEventListener('mousemove',e=>{if(!dragging)return;const dx=e.clientX-lastX,dy=e.clientY-lastY;lastX=e.clientX;lastY=e.clientY;theta+=dx*0.005;phi+=dy*0.005;const lim=Math.PI/2-0.01;phi=Math.max(-lim,Math.min(lim,phi));});
    window.addEventListener('wheel',e=>{e.preventDefault();const k=Math.exp(-e.deltaY*0.001);radius*=k;radius=Math.max(minRadius,Math.min(maxRadius,radius));},{passive:false});
    function resize(){const dpr=Math.min(window.devicePixelRatio||1,2);canvas.width=Math.floor(window.innerWidth*dpr);canvas.height=Math.floor(window.innerHeight*dpr);canvas.style.width=window.innerWidth+'px';canvas.style.height=window.innerHeight+'px';gl.viewport(0,0,canvas.width,canvas.height);gl.uniform1f(loc.uSize,params.particleSize*dpr);}
    window.addEventListener('resize',resize);
    gl.clearColor(0,0,0,0);
    gl.disable(gl.DEPTH_TEST);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.ONE,gl.ONE);
    gl.uniform1f(loc.uFlowSpeed,params.flowSpeed);
    gl.uniform1f(loc.uMinY,params.minY);
    gl.uniform1f(loc.uMaxY,params.maxY);
    gl.uniform1f(loc.uNeck,params.neckRadius);
    gl.uniform1f(loc.uFlare,params.flare);
    gl.uniform1f(loc.uTwistTurns,params.twistTurns);
    gl.uniform1f(loc.uFieryHue,params.fieryHue);
    gl.uniform1f(loc.uPulseTime,-10.0);
    resize();
    const button=document.querySelector('.glass-button');
    let start=performance.now(),pulseStart=-10.0;
    button.addEventListener('click',()=>{pulseStart=(performance.now()-start)/1000;gl.uniform1f(loc.uPulseTime,pulseStart);});
    function frame(){
      const now=performance.now();const t=(now-start)/1000;
      const aspect=canvas.width/canvas.height;
      const proj=perspective(Math.PI*70/180,aspect,0.1,200.0);
      const eye=[radius*Math.cos(phi)*Math.cos(theta),radius*Math.sin(phi),radius*Math.cos(phi)*Math.sin(theta)];
      const view=lookAt(eye,[0,0,0],[0,1,0]);
      gl.uniformMatrix4fv(loc.uProj,false,proj);
      gl.uniformMatrix4fv(loc.uView,false,view);
      gl.uniform1f(loc.uTime,t);
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.drawArrays(gl.POINTS,0,params.numParticles);
      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);
  </script>
